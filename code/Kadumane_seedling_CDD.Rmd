---
title: "Density-dependence seedling mortality in Kadumane"
author: "Robert Bagchi and Ashwin Viswanathan"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  tufte::tufte_handout:
  number_sections: yes
toc: true

---
## set up

```{r load_packages}
library(tidyverse)
library(ggthemes)
library(knitr)

#library(vegan)
#library(grid)
#library(geosphere)
#library(mgcv)
library(glmmTMB)
library(DHARMa)
library(broom.mixed)
library(ggeffects)
library(sjPlot)
library(patchwork)
```

```{r graphic_setup}
theme_set(theme_tufte())
```

# Data 

Load data

```{r load_data}
sp_codes <- read_csv("data/sp_codes.csv")
site_dat <- read_rds("data/kadumane_site_metadata.rds")
sdls <- read_rds("data/kadumane_seedlings.rds")
plot_dat <- read_rds("data/kadumane_plot_metadata.rds")

```

1. Join in site and plot meta-data.

2. Remove rows for species with no seedlings at start of the census in plot.

3. Select species that 
* Are recorded in at least 5 plots.
* Vary in density among plots.
* Are groups of many (unidentified) species with the same code.

```{r select_species}
sdls <-  sdls |> left_join(site_dat) |> left_join(plot_dat) |> 
  filter(census.start > 0)

## find species with enough individuals and variation in density to allow 
## analysis
sp_list <- group_by(sdls, species) |> 
  summarise(abund = sum(census.start) ,  ## total abund
            n = sum(census.start > 0), ## number of plots withe species
            sd_dens = sd(census.start[census.start > 0])) |> ##var in density
  filter(n > 1) |> arrange(n)
## only lose 8 species by restricting to 5 or more occurrences (instead of 1)
## Seems reasonable. Also removing species that were unreliably identified.
## 
## @Ashwin - what was SC and Artoh?
sp_list <- filter(sp_list, n > 4, !(species %in% c("Palm", "Artoh", "SC")),
                  sd_dens > 0) 
sdls <- filter(sdls, species %in% sp_list$species)
dim(sdls) ## 968 columns

```

Rename columns, add total seedling density, scale and centre data.

```{r data_wrangling}
## shorten names
sdls <- rename(sdls, 
               "trt_F" = "treatment.fungicide", 
               "trt_I" = "treatment.insecticide", 
               "Pr_m" = "proportion.mortality",
               "gr" = "group",
               "loc" = "location")
                ## group causes problems with some helper funcs
## add total density
tot_dens <- sdls |> group_by(site, loc, gr, plot) |> 
  summarise(tot_dens = sum(census.start))

## add species mean density
## divide by total number of plots = 21 sites x 4 locs * 3 groups * 5 plots
sp_mean_dens <- sdls |> group_by(species) |> 
  summarise(sp_mean_dens = sum(census.start)/(21*4*3*5), 
            sp_mean_surv = sum(census.final)/sum(census.start)) 


sdls <- left_join(sdls, tot_dens, by = c("site", "loc", "gr", "plot")) |> 
  left_join(select(sp_mean_dens, - sp_mean_surv))

#scale density by mean, fix couple of NAs and calculate log density
sdls <- mutate(sdls, 
               slope.degrees = replace_na(slope.degrees, 5), 
               Pr_s = 1 - Pr_m,
               con_dens = census.start,
               con_dens_s = con_dens/sp_mean_dens,
               slope.degrees_s = as.vector(scale(slope.degrees)),
                trt_F = factor(trt_F, labels = c("0", "F")),
                trt_I = factor(trt_I, labels = c("0", "I"))
               )
dim(sdls) ## 968 species x plot combinations
sdls |> summarise(n_sdls = sum(census.start), 
                  n_survs = sum(census.final),
                  n_species = n_distinct(species)) |> knitr::kable()
```


# Models

## Raw conspecific density model

Fitting a model of mortality as a function of initial conspecific density, 
initial total density, biocide treatment and fragment area (and their
interactions).

Also including slope of plot and random intercepts for plot, nested in location,
nested in site. Random slopes and intercepts are included for each species to
examine how density dependence varies among species.

```{r fit_model, eval = FALSE, include = FALSE}
# species random intercept and slope
m_cdd_ris <- glmmTMB(Pr_s ~ slope.degrees_s + 
                       (scale(tot_dens) + scale(con_dens)) * 
                       (trt_I + trt_F) *
                       scale(fragment.size) +
                       (scale(con_dens) + scale(tot_dens)||species) +
                       ## setting cor to 0 to converge 
                       (1|site/loc/gr/plot), 
                     weights = census.start, data = sdls, 
                     family=binomial)
## species random intercept model
m_cdd_ri <- glmmTMB(Pr_s ~ slope.degrees_s + 
                      (scale(tot_dens) + scale(con_dens)) * 
                      (trt_I + trt_F) *
                      scale(fragment.size) +
                      (1|species) +
                      (1|site/loc/gr/plot), 
                    weights = census.start, data = sdls, 
                    family=binomial)
AIC(m_cdd_ris, m_cdd_ri)
## random-intercept only version a bit better.
```

Note that including the insecticide x fungicide interaction causes convergence
problems and doesn't seem to be important either. Removing for practicality.

###  Model diagnostics

```{r diagnostics, eval = FALSE, include = FALSE}
## no evidence of variation among species
res <- simulateResiduals(m_cdd_ri)
plot(res)


## look at relationship with covariates
diag_dat <- data.frame(m_cdd_ri$frame, res = res$fittedResiduals)

diag_dat <-   rename_with(diag_dat, ~ str_replace(.x, "scale\\.", "")) |> 
  rename_with(~str_replace(.x, "\\.$", "")) 

ggplot(diag_dat, aes(x = con_dens, y = res)) +  
  geom_point(aes(colour = species)) + 
  geom_hline(yintercept=0, linetype = "dashed") +
  geom_smooth(method="gam") ## no clear trend. 

ggplot(diag_dat, aes(x = fragment.size, y = res)) +  
  geom_point(aes(colour = species), position = "jitter") + 
  geom_hline(yintercept=0, linetype = "dashed") +
  geom_smooth(method="gam") ## no clear trend. 


ggplot(diag_dat, aes(x = con_dens, y = res)) +  
  facet_wrap(~trt_F + trt_I ) +
  geom_point(aes(colour = species)) +
  geom_smooth(method="gam") ## no trend with treatment

```

### Take-homes

* Model diagnostics are generally good.
* Diagnostics are slightly better for non-logged version. Logged version has
some evidence of quantiles deviating from expectations (removed logged
version now). 
* No evidence of trends between covariates and residuals. 

The log density model has a slightly lower AIC. A little poking around 
(not shown) suggests that excluding the largest values reverses this order, 
so that the non-logged version is better. 

Looks like the two models lead to roughly similar interpretation.

### Inference

The fixed effects

```{r inference, eval = FALSE, include = FALSE}
## Non-logged version
summary(m_cdd_ri)
terms_cdd <- names(fixef(m_cdd_ri)$cond)

#sjPlot::plot_model(m_cdd) ## bit busy
trt_cols <- terms_cdd[-c(1:2)]
trt_cols <- trt_cols[!str_detect(trt_cols, "tot")] 
trt_cols <- case_when(
  str_detect(trt_cols, "trt_II") ~ "Insecticide",
  str_detect(trt_cols, "trt_FF") ~ "Fungicide",
  .default = "Control")
            
tp_cdd_ri <- sjPlot::plot_model(m_cdd_ri, 
                    rm.terms = c("slope.degrees_s", 
                                 terms_cdd[str_detect(terms_cdd, "tot")]),
                   group.terms= trt_cols, colors="Set2", title=NA)


quantile(sdls$con_dens, seq(0, 1, 0.1))
quantile(site_dat$fragment.size, seq(0, 1, 0.1))
plot(ggpredict(m_cdd_ri, terms=c("con_dens[1:100, by=0.1]", 
                              "trt_F",
                              "fragment.size[1, 50, 100]"))) + theme_tufte()

## more formal figure

p_cdd_ri <- predict_response(m_cdd_ri, 
                                terms=c("con_dens[1:100, by = 1]", 
                                        "trt_F", "trt_I", 
                                        "fragment.size[1, 50, 100]"),
                             margin="marginalmeans")

pr_cdd_ri <- residualize_over_grid(p_cdd_ri, m_cdd_ri) |> 
   bind_cols(species = sdls$species) |> 
  mutate(trt = case_when(
    group == "0" & facet == "0" ~ "C",
    group == "F" & facet == "0" ~ "F",
    group == "0" & facet == "I" ~ "I",
    group == "F" & facet == "I" ~ "FI"), 
    facet_lab = "Fragment Area (ha)") |> 
  rename("con_dens" = "x", "frag_area" = "panel") |> 
  group_by(con_dens, trt, frag_area, facet_lab, species) |> 
  summarise(predicted = mean(predicted), n = n())

p_cdd_ri <- as.data.frame(p_cdd_ri) |> 
  mutate(trt = case_when(
    group == "0" & facet == "0" ~ "C",
    group == "F" & facet == "0" ~ "F",
    group == "0" & facet == "I" ~ "I",
    group == "F" & facet == "I" ~ "FI"), 
    facet_lab = "Fragment Area (ha)") |> 
  rename("con_dens" = "x", "frag_area" = "panel")

pl_cdd <- ggplot(filter(p_cdd_ri, trt !="FI"), 
       aes(x=con_dens, y = predicted, colour = trt)) +
  ggh4x::facet_nested(~facet_lab + frag_area) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = trt), 
              colour = NA, alpha = 0.3) + 
  geom_line() +
  geom_point(data = filter(pr_cdd_ri, trt != "FI")) +
  scale_colour_brewer(palette="Set2") + 
  scale_fill_brewer(palette="Set2") +
  labs(x = expression(Conspecific~density~(m^-2)), y = "Pr(Survival)", 
       colour = "Treatment", fill = "Treatment")
pl_cdd | tp_cdd_ri
```

Main conclusions
* Suppressing insects and fungi) increases survival. 
* Conspecific density reduces seedling survival.
* The protection by fungicide is less effective at high conspecific density
* There is a weak 3-way interaction between conspecific density, fragment size, 
and fungicide addition, so that the reduction in protection at high densities
is more evident in larger fragments.


## Scaled conspecific density models

The most abundant species initially will often have lower survival (fecundity/
survival trade-off). This could generate what looks like a density-dependent 
relationship when looking across species, even without a relationship 
within species (i.e., Simpson's paradox). 

```{r abundance_survival}
ggplot(sp_mean_dens, aes(x = log(sp_mean_dens), y = sp_mean_surv)) +
  geom_label(aes(label= species)) + geom_smooth(method = "lm") + theme_tufte()

## not the clearest pattern, but worth accounting for.
(ggplot(sdls, aes(x = scale((con_dens_s)), colour = species)) + geom_density())/
(ggplot(sdls, aes(x = scale((con_dens)), colour = species)) + geom_density()) + plot_layout(guides = "collect")
```

To account for this, we can scale conspecific density by dividing by mean
density and refitting the models.

```{r fit_scaled_models}
## models using species-scaled density
## 
## Random intercept model
m_cdd_s_ri <- glmmTMB(Pr_s ~ slope.degrees_s + 
                       (scale(tot_dens) + scale(con_dens_s)) * 
                       (trt_I + trt_F) *
                       scale(log(fragment.size)) +
                       (1|species) +
                       (1|site/loc/gr/plot), 
                     weights = census.start, data = sdls, 
                     family=binomial)
## Random intercept and slope model for species specific effects
m_cdd_s_ris <- glmmTMB(Pr_s ~ slope.degrees_s + 
                       (scale(tot_dens) + scale(con_dens_s)) * 
                       (trt_I + trt_F) * scale(log(fragment.size)) * 
                       (scale(con_dens_s) + scale(tot_dens)||species) +
                       ## setting cor to 0 to converge 
                       (1|site/loc/gr/plot), 
                     weights = census.start, data = sdls, 
                     family=binomial)
anova(m_cdd_s_ri, m_cdd_s_ris) ## random slope *much* better
```

Models fit without issues as long as we fix the covariance between random slopes
and intercepts to 0. 

The improvment with the random slopes model suggests we need to look at 
individual species.

### Diagnostics

```{r diag_scaled}
res_s <- simulateResiduals(m_cdd_s_ri)
plot(res_s) ## ok - some deviation from ideal residual distribution, but 
## acceptable.

## look at relationship with covariates
diag_dat <- data.frame(m_cdd_s_ri$frame, res = res_s$fittedResiduals)

diag_dat <-   rename_with(diag_dat, ~ str_replace(.x, "scale\\.", "")) |> 
  rename_with(~str_replace(.x, "\\.$", "")) 

ggplot(diag_dat, aes(x = con_dens_s, y = res)) +  
  geom_point(aes(colour = species)) + 
  geom_hline(yintercept=0, linetype = "dashed") +
  geom_smooth(method="gam") ## no trend. 

ggplot(diag_dat, aes(x = log.fragment.size., y = res)) +  
  geom_point(aes(colour = species), position = "jitter") + 
  geom_hline(yintercept=0, linetype = "dashed") +
  geom_smooth(method="gam") ## no trend. 

ggplot(diag_dat, aes(x = con_dens_s, y = res)) +  
  facet_wrap(~trt_F + trt_I ) +
  geom_point(aes(colour = species)) +
  geom_smooth(method="gam") ## no trend with treatment

```

The diagnostics aren't as perfect in the scaled case, but the scaled version
does seem to be sensible given the massive differences in density.

### Model inference

```{r inference_scaled}
summary(m_cdd_s_ri)
plot_model(m_cdd_s_ri, show.values=TRUE) + ylim(c(0.5, 2.5))
car::Anova(m_cdd_s_ri)
car::Anova(m_cdd_s_ris)
## Given lack of evidence for 3-way interactions, perhaps try only 2 way?
m_cdd_s_ri_2way <- glmmTMB(Pr_s ~ slope.degrees_s + 
                       ((scale(tot_dens) + scale(con_dens_s)) + 
                       (trt_I + trt_F) +
                       scale(log(fragment.size)))^2 +
                       (1|species) +
                       (1|site/loc/gr/plot), 
                     weights = census.start, data = sdls, 
                     family=binomial)
plot_model(m_cdd_s_ri_2way) + ylim(c(0.4, 2.5))
```

### Take-homes:

* Survival is negatively conspecific density dependent
* Fungicide reduces the density dependence, but the evidence is complex. In
the full model with a 3 way CDD:frag_area:F interaction, the  2-way cdd:F 
interaction is significant (P = 0.03). Note that the magnitude
of the effect (0.21) is 2/3rds of the overall conspecific density effect
(-0.32). Worth remarking on in the results. However, the Type 2 anova suggests
that the effect is conditional on the effect of fragment area - excluding the 
interaction weakens evidence for the 2-way interaction (P = 0.059) 
* CDD strengthens significantly with fragment area (P = 0.017).
* The interaction between fungicide, fragment area and CDD is not significant,
but its estimated magnitude (0.117) is almost equal (and opposite direction) to
the interaction between fragment area and density (-0.121). 

* Worth noting that survival also increases with total stem density, with a 
similar magnitude as with conspecific density.
* Survival also declines with fragment area.
* Insecticide increases survival independent of density, and its effect 
increases with fragment area.

### Models split by categorical fragment size 

The effect of fragment

```{r mod_by_fragsize}
# Using 3 categories
sdls <- mutate(sdls, 
               frag_sizeclass3 = cut(fragment.size, 
                                     quantile(site_dat$fragment.size, 
                                              c(0, 0.33, 0.66, 1)), 
                                        include.lowest=TRUE))

m_cdd_s_ri_frag <- lapply(split(sdls, f= sdls$frag_sizeclass3), 
                           function(d){
                             glmmTMB(Pr_s ~ slope.degrees_s + 
                                       (scale(tot_dens) + scale(con_dens_s)) * 
                                       (trt_I + trt_F) +
                                       (1|species) +
                                       ## setting cor to 0 to converge 
                                       (1|site/loc/gr/plot), 
                                     weights = census.start, data = d, 
                                     family=binomial)})
term_nms <- names(fixef(m_cdd_s_ri_frag[[1]])$cond) 

plot_models(m_cdd_s_ri_frag, 
            rm.terms=c("slope.degrees_s", 
            term_nms[str_detect(term_nms, "tot")]), ## declutter
            m.labels=names(m_cdd_s_ri_frag), p.shape=TRUE) +
  labs(colour = "Fragment Area")
map(m_cdd_s_ri_frag, summary)

## What about a single model with categorical fragment sizes

m_cdd_s_cat_ri <- glmmTMB(Pr_s ~ slope.degrees_s + 
                       (scale(tot_dens) + scale(con_dens_s)) * 
                       (trt_I + trt_F) *
                       frag_sizeclass3 +
                       (1|species) +
                       ## setting cor to 0 to converge 
                       (1|site/loc/gr/plot), 
                     weights = census.start, data = sdls, 
                     family=binomial)
summary(m_cdd_s_cat_ri)
car::Anova(m_cdd_s_cat_ri)

```

### Take-homes

The effect of fragment area is complex. 
* Density dependence is only present in large fragments.
* Fungicide removes the effect in these large fragments. 

Although the interaction between fragment size and cdd and fungicide is
not significantly different from 0, this is owed more to its uncertainty than
its magnitude. 

### Graphics

```{r plots_scaled}
labs <-  c("ConDens", "I", "F", "log(FragArea)",
              "ConDens:I", "ConDens:F", "log(FragArea):\n ConDens",
              "log(FragArea):I"  , "log(FragArea):F", 
              "log(FragArea):\n (ConDens:I)", 
              "log(FragArea):\n (ConDens:F)")
tp_cdd_s_ri <- 
  tidy(m_cdd_s_ri, conf.int = TRUE) |> 
  filter(effect == "fixed", 
         !str_detect(term, "tot_dens"), 
         !term %in% c("(Intercept)", "slope.degrees_s")) |> 
  mutate(labels = factor(labs, levels = rev(labs)), 
         Biocide = case_when(
           str_detect(term, "trt_II") ~  "Insecticide",
           str_detect(term, "trt_FF") ~ "Fungicide",
           .default =  "Control")) |> 
  ggplot(aes(y = labels, x = estimate, xmin = conf.low, xmax = conf.high, 
             colour = Biocide)) + 
  geom_pointrange() +
  geom_vline(xintercept=0, linetype = "dotted") +
  scale_colour_brewer(palette="Set2") +
  labs(y = NULL, x = "log(odds ratio)")  + 
  guides(colour = guide_legend(position = "top", direction = "horizontal", 
                               title.position = "top", title.hjust = 0.5)) +
  theme(
    legend.margin = margin(0, 0, 0, 0), 
    legend.justification.top = "left",
    legend.location = "plot",
    plot.title.position = "plot"
  )                                        
tp_cdd_s_ri

p_cdd_s_ri <- predict_response(m_cdd_s_ri, 
                                terms=c("con_dens_s[1:80, by = 1]", 
                                        "trt_F", "trt_I", 
                                        "fragment.size[5, 25, 125]"),
                             margin="marginalmeans")

pr_cdd_s_ri <- residualize_over_grid(p_cdd_s_ri, m_cdd_s_ri) |> 
   bind_cols(species = sdls$species) |> 
  mutate(trt = case_when(
    group == "0" & facet == "0" ~ "Control",
    group == "F" & facet == "0" ~ "Fungicide",
    group == "0" & facet == "I" ~ "Insecticide",
    group == "F" & facet == "I" ~ "FI"), 
    facet_lab = "Fragment Area (ha)") |> 
  rename("con_dens" = "x", "frag_area" = "panel") |> 
  group_by(con_dens, trt, frag_area, facet_lab, species) |> 
  summarise(predicted = mean(predicted), n = n())

p_cdd_s_ri <- as.data.frame(p_cdd_s_ri) |> 
  mutate(trt = case_when(
    group == "0" & facet == "0" ~ "Control",
    group == "F" & facet == "0" ~ "Fungicide",
    group == "0" & facet == "I" ~ "Insecticide",
    group == "F" & facet == "I" ~ "FI"), 
    facet_lab = "Fragment Area (ha)") |> 
  rename("con_dens" = "x", "frag_area" = "panel")

pl_cdd_s <- ggplot(filter(p_cdd_s_ri, trt !="FI"), 
       aes(x=con_dens, y = predicted, colour = trt)) +
  ggh4x::facet_nested(~facet_lab + frag_area) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = trt), 
              colour = NA, alpha = 0.3) + 
  geom_line() +
  geom_point(data = filter(pr_cdd_s_ri, trt != "FI")) +
  scale_colour_brewer(palette="Set2") + 
  scale_fill_brewer(palette="Set2", guide = "none") +
  labs(x = expression(Conspecific~density~(m^-2)), y = "Pr(Survival)", 
       colour = "Treatment") + theme(legend.position="none")


(pl_cdd_s  | tp_cdd_s_ri )  + 
  plot_layout(widths=c(0.6, 0.4))

```

### Plotting effects of  fragment area

The effects are complex and not terribly clear. To interrogate them more, here
are some plots

```{r fragarea_plots}
## Using the model split by area to 
sdls |> group_by(frag_sizeclass3) |> summarize(mean(fragment.size))

## plot the effect of density over fragment size
int_data <- sdls |> 
  mutate(con_dens_ss = scale(con_dens_s),
         tot_dens_s = scale(tot_dens),
         log_fragsize_s = scale(log(fragment.size)))

int_mod <- glmmTMB(Pr_s ~ slope.degrees_s + 
                     (tot_dens_s + con_dens_ss) *  
                     (trt_I + trt_F) * log_fragsize_s +
                     (1| species) +  
                     (1 | site/loc/gr/plot), 
                   weights = census.start, family = binomial, 
                   data = int_data)

preddat <- expand.grid(
  trt_F = levels(int_data$trt_F),
  con_dens_ss = 1,
  log_fragsize_s = seq(-2, 1.3, length =20))

xmat <- model.matrix(~ con_dens_ss + con_dens_ss:(trt_F + log_fragsize_s) +
                       con_dens_ss:trt_F:log_fragsize_s,
                     preddat)[ , -1]
preddat$int_hat <- as.vector(xmat %*% fixef(int_mod)$cond[colnames(xmat)])
vmat <- (vcov(int_mod)$cond[colnames(xmat), colnames(xmat)])
preddat$int_se <-  sqrt(diag(xmat %*% vmat %*% t(xmat)))

## Now insecticide
preddat_i <- expand.grid(
  trt_I = levels(int_data$trt_I),
  con_dens_ss = 1,
  log_fragsize_s = seq(-2, 1.3, length =20))

xmat <- model.matrix(~ con_dens_ss + con_dens_ss:(trt_I + log_fragsize_s) +
                       con_dens_ss:trt_I:log_fragsize_s,
                     preddat_i)[ , -1]
preddat_i$int_hat <- as.vector(xmat %*% fixef(int_mod)$cond[colnames(xmat)])
vmat <- (vcov(int_mod)$cond[colnames(xmat), colnames(xmat)])
preddat_i$int_se <-  sqrt(diag(xmat %*% vmat %*% t(xmat)))

preddat <- bind_rows(preddat |> rename("trt" = "trt_F"), 
                     filter(preddat_i, trt_I == "I") |> rename("trt" = "trt_I"))

preddat <- preddat |> mutate(.lower = int_hat - 1.96*int_se, 
                             .upper = int_hat + 1.96*int_se, 
                             frag_area = exp(log_fragsize_s*
                               sd(log(sdls$fragment.size)) +
                               mean(log(sdls$fragment.size))),
                             trt =factor(trt, 
                                         labels = c("Control", "Fungicide",
                                                    "Insecticide")))
int_plot <- ggplot(preddat, aes(x = frag_area)) + facet_wrap( ~ trt) + 
  geom_ribbon(aes(y = int_hat, ymin = .lower, ymax = .upper), alpha = 0.2, colour = NA) +
  geom_line(aes(y = int_hat)) + geom_hline(yintercept=0, linetype = "dotted") +
  #coord_trans(x = "log") +
  scale_x_continuous(trans = "log", breaks=c(2, 8, 32, 128)) +
  labs(x =  "Fragment area (ha)", 
       y = "Effect of conspecific density on survival")


sdls <- mutate(sdls, trt = case_when(
  trt_F == "F" ~ "F",
  trt_I == "I" ~ "I",
  .default = "C"), 
  trt = factor(trt, labels = c("Control", "Fungicide", "Insecticide")))
library(ggdist)

int_plot <- int_plot + ggdist::geom_dots(data = sdls, aes(x = fragment.size), y =  -1,
                             smooth = smooth_unbounded(), layout = "swarm", 
                             side = "bottom", binwidth = 0.04,# alpha = 0.7, 
                             overflow = "compress")+  ylim(c(-1, 0.5))

int_plot + ggdensity::geom_hdr_rug(data = sdls, aes(x = fragment.size))  +
  theme(legend.position="none")


## double checking results against interactions package (only works for 
## lme4 and 2-way interactions
test_mod_C <-  lme4::glmer(Pr_s ~ slope.degrees_s + trt_I +
                       (tot_dens_s + con_dens_ss) * 
                       log_fragsize_s +
                        (1|species) +
                        ## setting cor to 0 to converge 
                        (1|site/loc/gr/plot), 
                      weights = census.start,
                      data =filter(int_data, trt_F =="0") , 
                      family=binomial)

test_mod_F <-  lme4::glmer(Pr_s ~ slope.degrees_s + trt_I +
                       (tot_dens_s + con_dens_ss) * 
                       log_fragsize_s +
                        (1|species) +
                        ## setting cor to 0 to converge 
                        (1|site/loc/gr/plot), 
                      weights = census.start,
                      data =filter(int_data, trt_F =="F"), 
                      family=binomial)
interactions::johnson_neyman(test_mod_C, pred = con_dens_ss, 
                             modx =   log_fragsize_s)
exp(-1.73*sd(log(int_data$fragment.size)) + mean(log(int_data$fragment.size)))
interactions::johnson_neyman(test_mod_F, pred = con_dens_ss, 
                              modx = log_fragsize_s)
## basically the same result
int_plot + ggdist::geom_dots(data = sdls, aes(x = fragment.size), y =  -1,
                             smooth = smooth_unbounded(), layout = "swarm", 
                             side = "bottom", binwidth = 0.04,# alpha = 0.7, 
                             overflow = "compress")+  ylim(c(-1, 0.5)) +
  geom_vline(xintercept=2.05)


```

## Species specific inferences.

Initial analyses suggested that some species were heavily influencing the results. 
The random slope should partly account for that.

```{r species_effects}
sjPlot::plot_model(m_cdd_s_ris, type = "re", terms = "species", ri.nr = 1)
## very little variation among species in slopes, but perhaps obscured 
## by large variation in the intercept
sp_eff <- as.data.frame(ranef(m_cdd_s_ris, condVar = T)$cond$species)

sp_eff <- bind_cols(sp_eff, 
                    t(apply(attr(sp_eff, "condVar"), 3, function(x)
                      sqrt(diag(x)))))
names(fixef(m_cdd_s_ris)$cond)

names(sp_eff) <- c("Intercept", "con_dens", "tot_dens", 
                   "Intercept_se", "con_dens_se", "tot_dens_se")
sp_eff <- mutate(sp_eff, sp_names = row.names(sp_eff),
                 Intercept = Intercept + fixef(m_cdd_s_ris)$cond[1],
                 con_dens = con_dens + fixef(m_cdd_s_ris)$cond["scale(con_dens_s)"],
                 tot_dens = tot_dens + fixef(m_cdd_s_ris)$cond["scale(tot_dens)"])

sp_eff |> arrange(con_dens) |> 
  ggplot(aes(y = reorder(sp_names, con_dens), x = con_dens, 
             xmin = con_dens - 2*con_dens_se, 
             xmax = con_dens + 2*con_dens_se)) +
    geom_vline(xintercept=0, linetype = "dotted") +
  geom_pointrange() 

## TBH not very illuminating.

```


Little variation in cdd among species. 


Perhaps remove most abundant species to check if patterns are robust.

```{r species_influence}
sp_common <- sdls |> group_by(species) |> summarise(n = sum(census.start)) |> 
   arrange(desc(n)) |> pull(species)

sp_mods <- lapply(c("none", as.character(sp_common[1:5])), function(i) {
  update(m_cdd_s_ri, data = filter(sdls, !species == i))})
sp_codes <- mutate(sp_codes, spbin = paste(genus, species))
term_nms <- names(fixef(m_cdd_s_ri_frag[[1]])$cond)

plot_models(sp_mods,
            rm.terms = c("slope.degrees_s", 
                         term_nms[str_detect(term_nms, "tot")]),
            m.labels = c("None", 
                         sp_codes$spbin[match(sp_common[1:5], sp_codes$code)]),
            p.shape=TRUE) + labs(colour = "Species excluded") 

## Only species that makes a difference is S. rubicundum - removing it dampens
## interaction between density and fungicide. Symplocus affects insects a bit.
```


what about single species models?
```{r single_sp}
## base model
## remove species random effect
names(sp_common) <- sp_common
single_sp_mods <- map(sp_common[1:5], function(i) {
  update(m_cdd_s_ri, data = filter(sdls, species == i))})
names(single_sp_mods) <- sp_codes$spbin[match(names(single_sp_mods), sp_codes$code)]
single_sp_mods$All <- m_cdd_s_ris

map(single_sp_mods, summary)


plot_models(single_sp_mods, m.labels=names(single_sp_mods), p.shape=TRUE) 
## Cinnamonam distorts scale, so dropping it
plot_models(single_sp_mods[c(1:4, 6)], 
            rm.terms = c("slope.degrees_s", 
                         term_nms[str_detect(term_nms, "tot")]),
            m.labels=names(single_sp_mods)[c(1:4, 6)], 
            p.shape = TRUE, grid=TRUE) 

## perhaps too much complexity. Dropping 3-way interactions
## 

m_cdd_s_ri_2way <- glmmTMB(Pr_s ~ slope.degrees_s + 
                       (scale(tot_dens) + scale(con_dens_s)) *
                       (trt_I + trt_F) +
                       scale(log(fragment.size)) *
                         (scale(tot_dens) + scale(con_dens_s) + trt_I + trt_F) +
                       (1|site/loc/gr/plot), 
                     weights = census.start, data = sdls, 
                     family=binomial)

single_sp_mods <- map(sp_common[1:4], function(i) {
  update(m_cdd_s_ri_2way, data = filter(sdls, species == i))})
names(single_sp_mods) <- sp_codes$spbin[match(names(single_sp_mods), sp_codes$code)]
single_sp_mods$All <- m_cdd_s_ri_2way


plot_models(single_sp_mods, 
            rm.terms = c("slope.degrees_s", 
                         term_nms[str_detect(term_nms, "tot")]),
            m.labels=names(single_sp_mods), 
            p.shape = TRUE, grid=FALSE)  + labs(colour = "Species")

```

To  be honest, probably not enough data for individual species.  Dropping 
the 3-way interactions helps fit the models, but only notable effects are 
density dependence in Ventilago and effects of fragment size on symplocus. 


```{r sessioninfo}
sessionInfo()
```